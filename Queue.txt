#include <iostream>

using namespace std;

class Queue {
private:
	int* arr; //Указатель на динамически выделенный массив, а память под массив будет выделенна в конструкторе 
	int front;	//Индекс первого элемента очереди
	int back;	//Индекс последнего элемента очереди
	int capacity;	//Максимальная вместимость очереди
	int size;	//Текущее кол-во элементов в очереди
	
public:
	//Конструктор
	Queue(int capacity) {
		//Инициализация членов класса
		this->capacity = capacity;	//Устанавливаем макс вместимость очереди
		arr = new int[capacity];	//Выделяем память под массив размером capacity
		front = 0;	//Индекс первого элемента 0
		back = -1;	//Индекс последнего элемента -1
		size = 0;	//Текущий размер очереди 0
	}
	//Деструктор 
	~Queue() {
		delete[] arr;	//Освобождаем память, выделенную под массив
	}
	//Проверка, пуста ли очередь
	bool isEmpty() {
		return size == 0;	//Возвращаем true, если размер равен 0, false в противном случае
	}
	//Проверка, полна ли очередь
	bool isFull() {
		return size == capacity; //Возвращаем true, если размер равен максимальной вместимости, false в противном случае
	}
	// Добавление элемента в конец очереди 
	void enqueue(int element) {
		//Проверка, полона ли очередь
		if (isFull()) {
			cout << "Ошибка! Очередь полная!" << endl;
			return;
			/*Функция enqueue() объявлена как void enqueue(int element). 
			Это означает, что она не должна возвращать какое-либо значение. 
			Функции, объявленные как void, предназначены для выполнения действий (например, изменения состояния объекта), 
			а не для вычисления и возврата результата.*/
		}

		back = (back + 1) % capacity;	//Циклический буфер -  это структура данных, которая использует массив фиксированного размера для хранения данных, но при этом позволяет «заворачиваться» (wrap around) от конца массива к его началу. Это позволяет эффективно использовать память, избегая необходимости перемещать элементы при добавлении или удалении.
		/*Оператор % обеспечивает циклическое поведение.
         Если back достиг конца массива, он "заворачивается" в начало.
         Например, если capacity = 5 и back = 4, то (back + 1) % capacity = 0.*/
		
		arr[back] = element;
		size++;
	 }
	//Удаление элемента из начала очереди
	int dequeue() {
		//Проверка, полона ли очередь
		if (isEmpty()) {
			cout << "Ошибка! Очередь пуста!" << endl; // Выводим сообщение об ошибке, если очередь пуста.
			return -1;                          // Возвращаем -1 (или другое значение по умолчанию) в качестве индикатора ошибки.
												// Важно возвращать какое-то значение, так как функция возвращает int
		}

		int element = arr[front]; // Сохраняем значение элемента, находящегося в начале очереди.
		// Увеличиваем индекс front (с использованием циклического буфера).
		front = (front + 1) % capacity; // Оператор % обеспечивает циклическое поведение (как и в enqueue).
		size--;
		return element;  // Возвращаем удаленный элемент.
	}
	//получение первого элемента
	int getFront() {
		if (isEmpty()) {
			cout << "Ошибка! Очередь пуста!" << endl;
			return -1;
		}
		return arr[front];
	}
	//Получение последнего элемента
	int getBack() {
		if (isEmpty()) {
			cout << "Ошибка! Очередь пуста!" << endl;
			return -1;
		}
		return arr[back];
	}
	//Метод печати очереди
	void printQueue() {
		if (isEmpty()) {
			cout << "Ошибка! Очередь пуста!" << endl;
			return;
		}

		cout << "Queue contents: ";   // Выводим сообщение о содержимом очереди.
		int i = front;                // Начинаем с индекса front.
		for (int j = 0; j < size; ++j) { // Перебираем элементы очереди.
			cout << arr[i] << " ";     // Выводим текущий элемент.
			i = (i + 1) % capacity;    // Переходим к следующему элементу (с использованием циклического буфера).
		}
		cout << endl;                   // Выводим символ новой строки.
	}
};

int main() {
	Queue q(5); // Создаем очередь с максимальной вместимостью 5

	q.enqueue(10); // Добавляем элемент 10 в очередь
	q.enqueue(20); // Добавляем элемент 20 в очередь
	q.enqueue(30); // Добавляем элемент 30 в очередь

	q.printQueue(); // Вывод: Queue contents: 10 20 30

	cout << "Первый элемент: " << q.getFront() << endl; // Вывод: Front element: 10
	cout << "Послений элемент: " << q.getBack() << endl;   // Вывод: Back element: 30

	cout << "Удаленный элемент: " << q.dequeue() << endl; // Вывод: Dequeued element: 10

	q.printQueue(); // Вывод: Queue contents: 20 30

	q.enqueue(40); // Добавляем элемент 40 в очередь
	q.enqueue(50); // Добавляем элемент 50 в очередь
	q.enqueue(60); // Пытаемся добавить элемент 60, но очередь полна -> Queue Overflow!

	q.printQueue(); // Вывод: Queue contents: 20 30 40 50

	return 0; // Возвращаем 0, что означает успешное завершение программы.
}